 # Parallel Execution in Erigon

## Motivation

The Ethereum Virtual Machine (EVM) is designed so that transaction execution occurs deterministically and sequentially, with each transaction processed strictly one after another. While this ensures correct execution, it does not take advantage of the capabilities of modern multicore processors.

Some clients have experimented with optimistic concurrency control (OCC) to parallelize execution. However, these approaches offer inconsistent performance across blocks, and still fall short of achieving full parallelism.

The primary goal of this project is to implement parallel execution in the Erigon client, in a way that is compatible with EIP-7928. Specifically, we aim to implement Block-Level Access Lists (BALs) and use these data structures to parallelize:
- I/O operations,
- EVM execution, and
- State root computation.

Since I/O reads and EVM execution account for ~90% of block processing time, effective parallelization here could yield significant performance improvements. [Preliminary research](https://hackmd.io/X4Z4h-EQRPSiQF38rpN9aQ?view) suggests that certain types of BALs can drastically reduce or offer maximum I/O reductions:

![Speedup](https://hackmd.io/_uploads/rJ3rGIhxxx.png)

Block-Level Access Lists (BALs) are data structures that will reside in the block body, with their hash stored in the block header. As a result, this proposal requires a hard fork to be activated, currently scheduled for the Glamsterdam upgrade.

## Project description

The main objective of this project can be divided into two key components:
1. Implementing Block-Level Access Lists (BALs)
2. Enabling parallelism in EVM execution

To achieve this, the following tasks are planned:
- Block Level Access Lists
- Parallel execution
- Storage warming strategies
- Parallel commitment calculation
- Refactor Engine API to include BAL as plain json
- (optional) Refactor gaspool to calculate gas used from BAL
- (optional) Refactor snap sync be replacing heal step w/ BAL

In addition, we are developing a visualization and profiling tool to support developers and researchers. This tool will allow users to:
- Visualize dependency graphs and parallel execution traces
- Debug parallel execution flows with support for breakpoints
- Simulate and test various BAL configurations and execution strategies across multiple blocks

Since EIP-7928 is still under active discussion, the exact format and contents of the BAL are not finalized. This tooling aims to assist ongoing research by enabling experimentation with different BAL formats and measuring their impact on execution performance and determinism.

## Specification

The BAL have the following specification:
```
BlockAccessList
└── AccountChanges[]
    ├── address: Address (20 bytes)
    ├── storage_changes: SlotChanges[]
    │   ├── slot: StorageKey (32 bytes)
    │   └── changes: StorageChange[]
    │       ├── tx_index: uint16
    │       └── new_value: StorageValue (32 bytes)
    ├── storage_reads: SlotRead[]
    │   └── slot: StorageKey (32 bytes)
    ├── balance_changes: BalanceChange[]
    │   ├── tx_index: uint16
    │   └── post_balance: Balance (12 bytes)
    ├── nonce_changes: NonceChange[]
    │   ├── tx_index: uint16
    │   └── new_nonce: uint64
    └── code_changes: CodeChange[]
        ├── tx_index: uint16
        └── new_code: CodeData (variable)
```

### Consensus Layer changes:

In the proposed design, Block-Level Access Lists (BALs) are generated by the block builder and are signed alongside the block by the block proposer. As part of block validation, validators are required to verify the correctness of the BAL included in the block.

### Execution Layer Changes:

Once validated, the Execution Layer (EL) can use the BAL to construct a dependency graph, which enables safe and efficient parallel execution:

![Dependency Graph](https://dependency.pics/graphs/22967260.png)

A draft specification for BALs and their integration into EVM execution is available in a [separate Execution Spec branch](https://github.com/ethereum/execution-specs/compare/master...nerolation:execution-specs:BALs).

There are 6 possible BAL designs that are being [discussed](https://hackmd.io/X4Z4h-EQRPSiQF38rpN9aQ?view):
1. Addresses and slots: Enables parallel I/O.
2. Addresses and slots + post-tx modified values (EIP-7928): Supports parallel I/O and fully parallel execution.
3. Addresses and slots + pre-block slot values: Enables near-zero I/O.
4. Addresses and slots + pre-block account and slot values: Enables near-zero I/O.
5. Addresses and slots + pre-block slot values + post-tx modified values: Combines near-zero I/O, fully parallel execution, and parallel state root computation.
6. Addresses and slots + pre-tx account and slot values: Enables near-zero I/O and fully parallel execution.

Since transaction sizes and workloads can vary significantly, assigning transactions to execution threads requires careful scheduling. This behavior is not specified in EIP-7928 and will need to be explored during implementation. A naive approach is to distribute transactions across cores using a greedy algorithm based on each transaction’s number of dependencies  present in the BAL (i.e., the number of accessed storage slots and accounts), which tends to correlate more closely with actual execution cost.

## Roadmap

Implementing Block-Level Access Lists (BALs) and integrating them into the state transition process should be relatively straightforward. The more complex challenge lies in designing an effective parallel execution algorithm, which largely depends on the final structure of the BAL. If BALs include both reads and writes, parallel execution becomes simpler. If not, we may need to rely on JIT (Just-In-Time) reads or introduce a cache-aware data structure to resolve dependencies dynamically.

### Phase 1 (Weeks 3–6): Deep Dive

This phase focused on foundational work:
- Conducting in-depth research on BALs and EIP-7928
- Studying related Ethereum Improvement Proposals (EIPs)
- Gaining familiarity with the Erigon codebase
- Developing tools for visualization and profiling

This phase has been completed.

### Phase 2 (Weeks 7–10): Prototyping & Research Collaboration

Goals for this phase:
- Prototype various BAL designs
- Evaluate trade-offs in structure, size, and inference
- Begin iterating on implementation details within Erigon
- Collaborate with the research team to improve the EIP through real data and feedback

### Phase 3(Weeks 11-15):

Focus areas:
- Implement parallel I/O reads based on BAL dependencies
- Enable parallel EVM execution, guided by dependency graphs
- Ensure deterministic and safe thread execution scheduling

### Phase 4(Weeks 17-21):

Final implementation steps:
- Validate that the pre-generated BALs match those created during live execution
- Implement additional features, including:
    - Parallel commitment generation
    - Storage pre-warming strategies
    - Block-level gas usage computation
    - Snap sync refactoring using BALs
- Look into other improvements in the execution which might be checking for transactions that appear dependent but they perform commutative operations e.g. they both increase an integer value.

## Possible challenges

This implementation, like those in other clients, will constantly evolve based on feedback from the research team. After evaluating the performance of various BAL versions, some parts of the BAL may be removed to make it leaner and reduce its impact on bandwidth.
On the other side the smaller the BAL, the more computation will be needed to be done at runtime or through preprocessing.
This EIP will be the first to use SSZ serialization in the execution layer, which could introduce additional complexity. Additionally, transferring the BAL from the Consensus Layer (CL) to the Execution Layer (EL) via the Engine API might require a different serialization method or possibly just plain JSON. These uncertainties still need to be resolved.

## Goal of the project

The project will be considered successful if it achieves a meaningful execution speedup. The criteria for success are:
- Full implementation of EIP-7928, including:
   - Adding BAL verification in the state transition function
   - Pre-warming addresses
- Parallel Execution, including:
   - Using access lists to pre-warm addresses
   - Implementing deterministic parallel execution
   - Benchmarking
    
### Mentors

TBD

## Resources

- [EIP-7928](https://eips.ethereum.org/EIPS/eip-7928)
- [Block-level Access Lists (BALs)](https://ethresear.ch/t/block-level-access-lists-bals/22331)
- [Block-level Access Lists (BAL): Benchmark and Overhead](https://hackmd.io/X4Z4h-EQRPSiQF38rpN9aQ?view)
- [Block Access List (BAL) Size Analysis](github.com/nerolation/EIPs/blob/4323a0ef70b322d1dde1fb69ed5fed6026dc3e1f/assets/eip-7928/bal_size_analysis.md)
- [eth-bal-analysis](https://github.com/nerolation/eth-bal-analysis)
- [Execution Dependencies](https://ethresear.ch/t/execution-dependencies/22150)
- [Draft Execution-specs Implementation](https://github.com/ethereum/execution-specs/compare/master...nerolation:execution-specs:BALs)
